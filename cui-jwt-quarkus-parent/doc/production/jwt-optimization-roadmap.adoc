= JWT Performance Optimization Roadmap
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Purpose

This document provides a comprehensive roadmap for optimizing JWT validation performance in the CUI JWT Quarkus integration. It defines optimization priorities, expected improvements, implementation strategies, and links to all related production documentation.

== Related Documentation

**Performance Analysis and Monitoring**:

* xref:jfr-analysis-findings.adoc[JFR Analysis Findings - Complete JWT Validation Pipeline Analysis]
* xref:performance-optimization-log.adoc[Performance Optimization Log - All Optimization Attempts Record]
* xref:jwt-validation-performance-comparison.adoc[JWT Validation Performance Comparison - Baseline Analysis]

**Implementation Guides**:

* xref:JFR-Profiling-Guide.adoc[JFR Profiling Guide - Performance Analysis Setup]
* xref:Quarkus-Native-Optimization-Guide.adoc[Quarkus Native Optimization Guide - Build Configuration]

== Executive Summary

**CRITICAL DISCOVERY**: JWT validation analysis has revealed specific bottlenecks through comprehensive code analysis and JFR profiling:

* **Signature Verification**: 50-60% of processing time (cryptographic operations + JWKS key lookup)
* **JSON Parsing**: 15-20% of processing time (Jakarta JSON API with security limits)
* **JWKS Key Loading**: 10-15% of processing time (potential bug: keys should be preloaded, health checks should be bypassed when all keys loaded)
* **Token/Claims Processing**: 10-15% of processing time (claim extraction and validation)

**Performance Gap Root Cause**:

* Library standalone: 30,000 ops/s
* Integration performance: 260 ops/s (115x slower - FIRST PRIORITY: investigate missing Quarkus optimizations)
* Primary bottlenecks: Network I/O (40-50%) + Cryptographic operations (30-40%)

**Key Insight**: The optimization focus is on closing the 115x performance gap between library capability (30k ops/s) and integration performance (260 ops/s) through missing Quarkus optimizations and JWT validation pipeline improvements.

== Current Performance Status

=== ‚úÖ Completed Analysis Phase

**JFR Pipeline Analysis**: Complete breakdown of `TokenValidator.processTokenPipeline()` method with performance impact assessment.

**Key Findings**:

1. **Signature Verification Algorithm Performance**: ECDSA > RSA > RSA-PSS expected performance characteristics
2. **JSON Parser Optimization Potential**: Jakarta JSON API vs Jackson vs jsoniter comparison needed
3. **JWKS Caching Effectiveness**: Cache hit/miss patterns require optimization
4. **Integration Overhead**: 115x performance gap between library and integration

**Performance Baselines Established**:

[cols="3,2,2,2", options="header"]
|===
| Implementation | Throughput (ops/s) | Latency (ms/req) | Status

| **NOOP (Framework Only)**
| 279,000-288,000
| ~0.35ms
| ‚úÖ Baseline established

| **Blocking (Virtual Threads)**
| 257-267
| 3.7-3.9ms
| ‚úÖ Current optimized baseline

| **TokenValidator Library (Research)**
| ~30,000
| ~0.033ms
| üìä Target performance level
|===

=== üóëÔ∏è Removed Experimental Implementations

**Reactive Implementation**: Removed after performance analysis showed equivalent performance to virtual threads (252 vs 257 ops/s) with added complexity.

**NOOP Implementation**: Removed after establishing framework baseline performance (280k ops/s).

== CRITICAL OPTIMIZATION RULES

**‚ö†Ô∏è RULE 1**: Focus optimization on identified JWT validation bottlenecks, NOT framework

**‚ö†Ô∏è RULE 2**: Test individual changes with >5% improvement threshold

**‚ö†Ô∏è RULE 3**: Record ALL attempts in xref:performance-optimization-log.adoc[Performance Optimization Log]

**‚ö†Ô∏è RULE 4**: Postpone caching (security implications) - optimize code first

=== Mandatory Process

1. **Baseline Measurement**: Use `benchmark-with-monitoring.sh` for all tests
2. **Single Change**: Implement ONLY ONE optimization at a time
3. **JFR Analysis**: Profile callstack for every optimization attempt
4. **Verification**: Document before/after metrics with concrete numbers
5. **Documentation**: Update performance logs immediately

=== Resource Utilization Targets

* **CPU Utilization**: ‚â•90% (currently 100%+ ‚úÖ)
* **Memory Utilization**: ‚â•90% (currently achieved ‚úÖ)
* **Improvement Threshold**: >5% throughput gain required
* **Analysis**: JFR profiling mandatory for understanding bottlenecks

== FIRST PRIORITY: Quarkus Integration Optimization Gap üö®

=== Status: CRITICAL - Must Investigate Immediately

**Objective**: Close the 115x performance gap between cui-jwt-validation library (30k ops/s) and Quarkus integration (260 ops/s).

**Critical Analysis Required**:

- [ ] **Research missing Quarkus native optimizations for cui-jwt-validation**
+
Investigate:
+
* Missing reflection configuration in CuiJwtProcessor.java
* Incomplete native image hints for cui-jwt-validation classes
* Missing build-time optimizations in Quarkus extension
* Potential CDI/dependency injection overhead

- [ ] **Verify cui-jwt-validation module build requirements**
+
**MANDATORY**: cui-jwt-validation module must be built BEFORE building native image for changes to take effect:
+
[source,bash]
----
# Required build sequence
./mvnw clean install -pl cui-jwt-validation
./mvnw clean install -pl cui-jwt-quarkus-parent/cui-jwt-quarkus-integration-tests -Pnative
----

- [ ] **Profile Quarkus-specific integration overhead**
+
Identify sources of 115x performance degradation:
+
* HTTP request/response processing layers
* JSON serialization/deserialization overhead  
* CDI proxy creation and method interception
* Missing Quarkus 3.20+ optimizations (reflection-free Jackson)

**This investigation has HIGHEST PRIORITY before all other optimizations.**

== Priority 2: Signature Algorithm Performance Optimization üî•

=== Status: Ready to Execute

**Objective**: Optimize signature verification performance for ALL JOSE-compliant algorithms. Since JWT signature algorithms are defined by JOSE Requirements, we must improve performance across all supported algorithms rather than favoring specific ones.

**Critical Constraint**: All JOSE algorithms must maintain equivalent performance - no algorithm selection bias allowed.

**Tasks**:

- [ ] **1.1** Benchmark ALL signature algorithms for optimization opportunities
+
Test optimization techniques across ALL JOSE algorithms:
+
* **ECDSA (ES256/384/512)**: JOSE required - optimize JDK crypto provider usage
* **RSA (RS256/384/512)**: JOSE required - optimize RSA verification efficiency  
* **RSA-PSS (PS256/384/512)**: JOSE required - optimize PSS parameter handling
+
**Note**: Must ensure Quarkus native compatibility for ALL algorithm optimizations.

- [ ] **1.2** Profile crypto provider performance optimizations
+
Optimize underlying cryptographic operations:
+
* JDK crypto provider configuration for native image
* Memory allocation patterns in signature verification
* Key material access patterns and caching

- [ ] **1.3** Implement signature verification result caching (if beneficial)
+
Cache verified tokens maintaining security:
+
* Target: Eliminate repeated crypto verification for identical tokens
* Security: Maintain token security while optimizing repeated verifications
* **Quarkus Native**: Ensure caching works correctly in native image

**Implementation Rule**: ALL optimizations must work for ALL JOSE algorithms in Quarkus native context.

== Priority 3: JSON Parser Performance Optimization üî•

=== Status: Ready to Execute

**Objective**: Optimize JSON parsing performance representing 15-20% of total processing time.

**Tasks**:

- [ ] **2.1** Compare JSON parser alternatives (Quarkus Native Compatible Only)
+
Test JWT payload parsing performance with libraries optimized for Quarkus native:
+
* **Jakarta JSON API** (current): Security-first design, native image compatible
* **Jackson ObjectMapper**: IF properly configured for Quarkus native (reflection-free mode)
* **Quarkus Jackson**: Built-in Quarkus Jackson extension with native optimizations
+
**MANDATORY**: Each library must be verified working and optimized for Quarkus native image before testing.

- [ ] **2.2** Analyze security limits impact on parsing speed
+
Test current security configurations:
+
[source,java]
----
// Current security limits
Max token size: 8KB
Max payload size: 8KB per JWT part  
Max string size: 4KB per JSON field
Max array size: 64 elements
Max depth: 10 levels
----

- [ ] **2.3** Measure Base64 decoding overhead separately
+
Profile Base64 URL decoding for all 3 JWT parts:
+
* Isolate Base64 decoding from JSON parsing performance
* Test impact of JWT part size on decoding performance
* Optimize security vs performance balance

**Implementation Rule**: ALL JSON parser alternatives must work correctly in Quarkus native image context.

== Priority 4: JWKS Caching Optimization üî•

=== Status: Ready to Execute

**Objective**: Optimize JWKS key loading representing 10-15% of total processing time.

**Tasks**:

- [ ] **4.1** Profile JWKS cache hit/miss patterns under load
+
Analyze cache effectiveness during benchmark runs:
+
* Measure cache hit rate for production workloads
* Measure HTTP call frequency for JWKS endpoints
* Profile issuer config resolution patterns

- [ ] **4.2** Optimize issuer config health check patterns (POTENTIAL BUG)
+
**CRITICAL**: Implement optimized path when all keys are loaded - eliminate health checks completely:
+
[source,java]
----
// OPTIMIZED: Skip health checks when keys preloaded
for (IssuerConfig config : issuerConfigs) {
    if (config.matchesIssuer(issuer)) {
        // If all keys loaded, skip health check
        if (config.areAllKeysLoaded()) {
            return config;
        }
        // Only check health if keys need loading
        if (config.isHealthy()) {
            return config;
        }
    }
}
----
+
**Investigation Required**: Current implementation may contain bug - JWKS keys should be preloaded and health checks bypassed when all keys available.

- [ ] **4.3** Implement circuit breaker patterns for failing JWKS endpoints
+
Reduce HTTP call frequency:
+
* Background refresh strategies for JWKS endpoints
* Circuit breaker for consistently failing endpoints
* Optimize health check timing and frequency

**Implementation Rule**: ALL JWKS optimizations must maintain security compliance and work correctly in Quarkus native image context.

== Implementation Strategy

=== Implementation Order (Critical Priority Sequence)

**FIRST**: Quarkus Integration Gap Analysis - MUST be completed before other optimizations

**SECOND**: Signature Algorithm Optimization - All JOSE algorithms must maintain equivalent performance

**THIRD**: JSON Parser Replacement - Only Quarkus native compatible alternatives

**FOURTH**: JWKS Caching Enhancement - Focus on health check bypass when keys preloaded

=== Build Requirements

**CRITICAL BUILD SEQUENCE**:

[source,bash]
----
# MANDATORY: Build cui-jwt-validation first for changes to take effect
./mvnw clean install -pl cui-jwt-validation

# Then build native integration
./mvnw clean install -pl cui-jwt-quarkus-parent/cui-jwt-quarkus-integration-tests -Pnative
----

=== Success Criteria

**Measurement Focus**: Closing the 115x performance gap through systematic optimization of identified bottlenecks.

**Performance Target**: Progress toward library capability (30k ops/s) from current integration performance (260 ops/s).

== Optimization Constraints and Requirements

=== Quarkus Native Compatibility Requirements

**MANDATORY**: All optimizations must work correctly in Quarkus native image context:

* Reflection configuration must be complete for any new libraries
* Native image compatibility testing required for all changes
* Security compliance validation for parser/algorithm modifications
* Performance testing must be conducted in native image mode

=== Security Compliance Requirements

**MANDATORY**: All optimizations must maintain current security standards:

* JSON parsing security limits must be preserved or improved
* JOSE algorithm compliance must be maintained across all optimizations
* Token validation security must not be compromised for performance gains
* Authentication and authorization behavior must remain unchanged

== Success Metrics and Monitoring

=== Performance Targets

**Primary Success Criteria**:

* **Performance Gap Closure**: Progress toward library capability (30k ops/s)
* **CPU Utilization**: Maintain ‚â•90% during load testing
* **Memory Utilization**: Maintain efficient usage (<90% acceptable)
* **Security Compliance**: No degradation in security standards

**Verification Process**:

* Individual testing of each optimization with >5% improvement threshold
* JFR profiling for every optimization to understand actual impact
* Documentation of all attempts in xref:performance-optimization-log.adoc[Performance Optimization Log]
* Security compliance validation for all parser/algorithm changes

=== Risk Mitigation

**Technical Risk Management**:

* Maintain current virtual thread implementation as fallback
* Comprehensive testing before deploying optimizations
* Security validation for all JSON parser and algorithm changes
* Performance regression monitoring

**Process Risk Management**:

* Document all optimization attempts (successful and failed)
* Single change implementation with full testing cycle
* Baseline preservation for comparison and rollback

== Next Actions

=== Immediate Actions

**CRITICAL FIRST PRIORITY**: Quarkus Integration Gap Investigation

1. **Research missing Quarkus optimizations** for cui-jwt-validation integration
2. **Verify build requirements** - cui-jwt-validation module must be built before native image
3. **Profile integration overhead** to identify the 115x performance gap sources

**Subsequent Optimization Priorities**:

1. **Signature Algorithm Optimization**: Improve performance for ALL JOSE algorithms in Quarkus native context
2. **JSON Parser Investigation**: Test Quarkus native compatible alternatives only
3. **JWKS Health Check Optimization**: Implement bypassing when all keys are preloaded

=== Documentation and Monitoring

**Continuous Activities**:

* Update xref:performance-optimization-log.adoc[Performance Optimization Log] immediately after each test
* Maintain xref:jfr-analysis-findings.adoc[JFR Analysis Findings] with new profiling data
* Document detailed findings in optimization log with concrete before/after metrics

**Reference Guides**:

* Use xref:JFR-Profiling-Guide.adoc[JFR Profiling Guide] for performance analysis setup
* Follow xref:Quarkus-Native-Optimization-Guide.adoc[Quarkus Native Optimization Guide] for build configuration

== Security Considerations

=== Security-First Optimization Approach

**Critical Security Rules**:

1. **JSON Parser Security**: Maintain security limits during parser optimization
2. **Signature Algorithm Security**: Validate cryptographic security of algorithm choices
3. **Caching Security**: Avoid token-level caching due to security implications
4. **Verification Security**: Maintain signature verification integrity

**Security Validation Process**:

* Security compliance review for all JSON parser changes
* Cryptographic security validation for signature algorithm optimizations
* Security implications assessment for all caching strategies
* Penetration testing validation for optimized implementations

== Appendix: Optimization History

=== ‚úÖ Verified Successful Optimizations

**Virtual Threads Implementation**:

* **Status**: ‚úÖ Implemented and verified
* **Impact**: 24-30% improvement in throughput
* **Configuration**: `@RunOnVirtualThread` annotation at class level
* **Verification**: JMH benchmark performance improvement confirmed

**Native Image Compiler Optimization**:

* **Status**: ‚úÖ Implemented and verified  
* **Impact**: Additional performance improvement
* **Configuration**: `-O2` compiler flag in native build args
* **Verification**: Benchmark performance improvement confirmed

=== ‚ùå Failed Optimization Attempts

**Epsilon GC (No-Op Garbage Collector)**:

* **Status**: ‚ùå Failed - Fundamental incompatibility
* **Root Cause**: JWT validation creates 10MB+/second allocation rate
* **Reason**: Epsilon GC performs zero garbage collection, making failure mathematically inevitable
* **Outcome**: Reverted to Serial GC with documented analysis

**Memory Limit Optimizations**:

* **Status**: ‚ùå Limited benefit
* **Testing**: 48MB, 64MB, 80MB memory limits tested
* **Outcome**: <90% memory utilization acceptable for optimization testing
* **Result**: Focus shifted to CPU-bound optimizations

== See Also

* xref:jfr-analysis-findings.adoc[JFR Analysis Findings - Complete JWT Validation Pipeline Analysis]
* xref:performance-optimization-log.adoc[Performance Optimization Log - Detailed Optimization Attempt Records]
* xref:jwt-validation-performance-comparison.adoc[JWT Validation Performance Comparison - Baseline Performance Analysis]
* xref:JFR-Profiling-Guide.adoc[JFR Profiling Guide - Performance Analysis and Monitoring Setup]
* xref:Quarkus-Native-Optimization-Guide.adoc[Quarkus Native Optimization Guide - Build Configuration and Optimization]