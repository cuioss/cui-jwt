= JWT Performance Optimization Roadmap
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Purpose

This document provides a comprehensive roadmap for optimizing JWT validation performance in the CUI JWT Quarkus integration. It defines optimization priorities, expected improvements, implementation strategies, and links to all related production documentation.

== Related Documentation

**Performance Analysis and Monitoring**:

* xref:jfr-analysis-findings.adoc[JFR Analysis Findings - Complete JWT Validation Pipeline Analysis]
* xref:performance-optimization-log.adoc[Performance Optimization Log - All Optimization Attempts Record]
* xref:jwt-validation-performance-comparison.adoc[JWT Validation Performance Comparison - Baseline Analysis]

**Implementation Guides**:

* xref:JFR-Profiling-Guide.adoc[JFR Profiling Guide - Performance Analysis Setup]
* xref:Quarkus-Native-Optimization-Guide.adoc[Quarkus Native Optimization Guide - Build Configuration]

== Executive Summary

**CRITICAL DISCOVERY**: JWT validation analysis has revealed specific bottlenecks through comprehensive code analysis and JFR profiling:

* **Signature Verification**: 50-60% of processing time (cryptographic operations + JWKS key lookup)
* **JSON Parsing**: 15-20% of processing time (Jakarta JSON API with security limits)
* **JWKS Key Loading**: 10-15% of processing time (HTTP calls and health checks)
* **Token/Claims Processing**: 10-15% of processing time (claim extraction and validation)

**Performance Gap Root Cause**:

* Library standalone: 30,000 ops/s
* Integration performance: 260 ops/s (115x slower)
* Primary bottlenecks: Network I/O (40-50%) + Cryptographic operations (30-40%)

**Key Insight**: The optimization focus has shifted from framework overhead to specific JWT validation pipeline bottlenecks identified through detailed method-level analysis.

== Current Performance Status

=== ‚úÖ Completed Analysis Phase

**JFR Pipeline Analysis**: Complete breakdown of `TokenValidator.processTokenPipeline()` method with performance impact assessment.

**Key Findings**:

1. **Signature Verification Algorithm Performance**: ECDSA > RSA > RSA-PSS expected performance characteristics
2. **JSON Parser Optimization Potential**: Jakarta JSON API vs Jackson vs jsoniter comparison needed
3. **JWKS Caching Effectiveness**: Cache hit/miss patterns require optimization
4. **Integration Overhead**: 115x performance gap between library and integration

**Performance Baselines Established**:

[cols="3,2,2,2", options="header"]
|===
| Implementation | Throughput (ops/s) | Latency (ms/req) | Status

| **NOOP (Framework Only)**
| 279,000-288,000
| ~0.35ms
| ‚úÖ Baseline established

| **Blocking (Virtual Threads)**
| 257-267
| 3.7-3.9ms
| ‚úÖ Current optimized baseline

| **TokenValidator Library (Research)**
| ~30,000
| ~0.033ms
| üìä Target performance level
|===

=== üóëÔ∏è Removed Experimental Implementations

**Reactive Implementation**: Removed after performance analysis showed equivalent performance to virtual threads (252 vs 257 ops/s) with added complexity.

**NOOP Implementation**: Removed after establishing framework baseline performance (280k ops/s).

== CRITICAL OPTIMIZATION RULES

**‚ö†Ô∏è RULE 1**: Focus optimization on identified JWT validation bottlenecks, NOT framework

**‚ö†Ô∏è RULE 2**: Test individual changes with >5% improvement threshold

**‚ö†Ô∏è RULE 3**: Record ALL attempts in xref:performance-optimization-log.adoc[Performance Optimization Log]

**‚ö†Ô∏è RULE 4**: Postpone caching (security implications) - optimize code first

=== Mandatory Process

1. **Baseline Measurement**: Use `benchmark-with-monitoring.sh` for all tests
2. **Single Change**: Implement ONLY ONE optimization at a time
3. **JFR Analysis**: Profile callstack for every optimization attempt
4. **Verification**: Document before/after metrics with concrete numbers
5. **Documentation**: Update performance logs immediately

=== Resource Utilization Targets

* **CPU Utilization**: ‚â•90% (currently 100%+ ‚úÖ)
* **Memory Utilization**: ‚â•90% (currently achieved ‚úÖ)
* **Improvement Threshold**: >5% throughput gain required
* **Analysis**: JFR profiling mandatory for understanding bottlenecks

== Priority 1: Signature Algorithm Performance Testing üî•

=== Status: Ready to Execute

**Objective**: Test signature algorithm performance characteristics based on JFR analysis showing 50-60% of processing time spent in signature verification.

**Tasks**:

- [ ] **1.1** Benchmark signature algorithms comparative performance
+
Configure test issuers with different signature algorithms:
+
* **ECDSA (ES256/384/512)**: Expected fastest verification performance
* **RSA (RS256/384/512)**: Most common, moderate performance  
* **RSA-PSS (PS256/384/512)**: Expected slowest due to PSS parameters

- [ ] **1.2** Measure algorithm-specific JFR performance
+
Profile signature verification methods specifically:
+
* `TokenSignatureValidator.validateSignature()`
* JDK crypto provider performance for each algorithm
* JWKS key lookup patterns and cache effectiveness

- [ ] **1.3** Implement signature verification result caching (if beneficial)
+
Cache verified tokens for short TTL (30-60 seconds):
+
* Target: Eliminate repeated crypto verification for identical tokens
* Expected Impact: 50-60% improvement for cached tokens
* Security: Maintain token security while optimizing repeated verifications

**Expected Impact**: 20-40% improvement from optimal algorithm choice

**Risk**: Low (configuration changes only)

== Priority 2: JSON Parser Performance Optimization üî•

=== Status: Ready to Execute

**Objective**: Optimize JSON parsing performance representing 15-20% of total processing time.

**Tasks**:

- [ ] **2.1** Compare JSON parser alternatives
+
Test JWT payload parsing performance (typically 1-4KB):
+
* **Jakarta JSON API** (current): Security-first design with limits
* **Jackson ObjectMapper**: Industry standard with performance focus
* **jsoniter**: High-performance JSON library
* **fast-json**: Alternative high-performance option

- [ ] **2.2** Analyze security limits impact on parsing speed
+
Test current security configurations:
+
[source,java]
----
// Current security limits
Max token size: 8KB
Max payload size: 8KB per JWT part  
Max string size: 4KB per JSON field
Max array size: 64 elements
Max depth: 10 levels
----

- [ ] **2.3** Measure Base64 decoding overhead separately
+
Profile Base64 URL decoding for all 3 JWT parts:
+
* Isolate Base64 decoding from JSON parsing performance
* Test impact of JWT part size on decoding performance
* Optimize security vs performance balance

**Expected Impact**: 15-20% improvement from faster JSON processing

**Risk**: Medium (library changes with security validation required)

== Priority 3: JWKS Caching Optimization üî•

=== Status: Ready to Execute

**Objective**: Optimize JWKS key loading representing 10-15% of total processing time.

**Tasks**:

- [ ] **3.1** Profile JWKS cache hit/miss patterns under load
+
Analyze cache effectiveness during benchmark runs:
+
* Target >95% cache hit rate for production workloads
* Measure HTTP call frequency for JWKS endpoints
* Profile issuer config resolution patterns

- [ ] **3.2** Optimize issuer config health check patterns
+
Reduce network I/O overhead:
+
[source,java]
----
// Current health check iteration
for (IssuerConfig config : issuerConfigs) {
    if (config.isHealthy() && config.matchesIssuer(issuer)) {
        return config;
    }
}
----

- [ ] **3.3** Implement circuit breaker patterns for failing JWKS endpoints
+
Reduce HTTP call frequency:
+
* Background refresh strategies for JWKS endpoints
* Circuit breaker for consistently failing endpoints
* Optimize health check timing and frequency

**Expected Impact**: 10-15% improvement from reduced network I/O

**Risk**: Medium (configuration and caching logic changes)

== Implementation Strategy

=== Phase 1: Core Optimizations (Week 1-2)

**Focus**: Implement highest-impact optimizations identified through JFR analysis

1. **Signature Algorithm Testing** - Quick configuration changes with immediate results
2. **JSON Parser Benchmarking** - Focused library comparison with security validation
3. **JWKS Caching Analysis** - Understanding current cache effectiveness

**Timeline**: 1-2 weeks for core optimization implementation

**Success Criteria**: 10-20x performance improvement (2,500-5,000 ops/s)

=== Phase 2: Advanced Optimizations (Week 2-3)

**Focus**: Implement more complex optimizations requiring architectural changes

1. **Signature Verification Caching** - Moderate complexity with security considerations
2. **JSON Parser Replacement** - Higher complexity with security validation
3. **JWKS Health Check Optimization** - Configuration tuning and monitoring

**Timeline**: 1-2 weeks for advanced optimization implementation

**Success Criteria**: 20-40x performance improvement (5,000-10,000 ops/s)

=== Phase 3: Architectural Changes (Week 3+)

**Focus**: Major architectural changes if core optimizations insufficient

1. **Token-Level Caching** - Complex security considerations (POSTPONED)
2. **Custom JSON Parsing Implementation** - Significant implementation effort
3. **Integration Overhead Reduction** - Quarkus-specific optimizations

**Timeline**: 2+ weeks for architectural changes

**Success Criteria**: 40-60x performance improvement (10,000-15,000 ops/s)

== Expected Performance Improvements

=== Realistic Targets (Phase 1-2)

**Target**: 2,500-5,000 ops/s (10-20x improvement)

**Breakdown**:

* Signature algorithm optimization: ~40% time savings
* JSON parsing optimization: ~15% time savings
* JWKS caching optimization: ~20% time savings  
* **Combined effect**: Potential 75% performance improvement

=== Stretch Targets (Phase 3)

**Target**: 10,000-15,000 ops/s (40-60x improvement)

**Requirements**:

* Architectural changes (token-level caching)
* Advanced signature verification optimizations
* Custom JSON parsing implementation
* Significant integration overhead reduction

=== Theoretical Maximum

**Target**: Approaching library performance limits (20,000-30,000 ops/s)

**Requirements**: Major architectural changes and custom implementations

== Success Metrics and Monitoring

=== Performance Targets

**Primary Success Criteria**:

* **Throughput**: >2,500 ops/s (10x minimum improvement)
* **Latency**: <0.4ms per request (10x improvement)
* **CPU Utilization**: Maintain ‚â•90% during load testing
* **Memory Utilization**: Maintain efficient usage (<90% acceptable)

**Verification Process**:

* Individual testing of each optimization with >5% improvement threshold
* JFR profiling for every optimization to understand actual impact
* Documentation of all attempts in xref:performance-optimization-log.adoc[Performance Optimization Log]
* Security compliance validation for all parser/algorithm changes

=== Risk Mitigation

**Technical Risk Management**:

* Maintain current virtual thread implementation as fallback
* Comprehensive testing before deploying optimizations
* Security validation for all JSON parser and algorithm changes
* Performance regression monitoring

**Process Risk Management**:

* Document all optimization attempts (successful and failed)
* Single change implementation with full testing cycle
* Baseline preservation for comparison and rollback

== Next Actions

=== Immediate Actions (This Week)

**Week 1 Priorities**:

1. **Execute Phase 1.1**: Benchmark signature algorithm performance (ECDSA vs RSA vs RSA-PSS)
2. **Execute Phase 2.1**: Compare JSON parser alternatives with security validation
3. **Execute Phase 3.1**: Profile JWKS cache effectiveness under load

**Preparation Requirements**:

* Set up signature algorithm test configurations
* Prepare JSON parser benchmark environment  
* Configure JWKS cache monitoring for analysis

=== Documentation and Monitoring

**Continuous Activities**:

* Update xref:performance-optimization-log.adoc[Performance Optimization Log] immediately after each test
* Maintain xref:jfr-analysis-findings.adoc[JFR Analysis Findings] with new profiling data
* Document detailed findings in optimization log with concrete before/after metrics

**Reference Guides**:

* Use xref:JFR-Profiling-Guide.adoc[JFR Profiling Guide] for performance analysis setup
* Follow xref:Quarkus-Native-Optimization-Guide.adoc[Quarkus Native Optimization Guide] for build configuration

== Security Considerations

=== Security-First Optimization Approach

**Critical Security Rules**:

1. **JSON Parser Security**: Maintain security limits during parser optimization
2. **Signature Algorithm Security**: Validate cryptographic security of algorithm choices
3. **Caching Security**: Avoid token-level caching due to security implications
4. **Verification Security**: Maintain signature verification integrity

**Security Validation Process**:

* Security compliance review for all JSON parser changes
* Cryptographic security validation for signature algorithm optimizations
* Security implications assessment for all caching strategies
* Penetration testing validation for optimized implementations

== Appendix: Optimization History

=== ‚úÖ Verified Successful Optimizations

**Virtual Threads Implementation**:

* **Status**: ‚úÖ Implemented and verified
* **Impact**: 24-30% improvement in throughput
* **Configuration**: `@RunOnVirtualThread` annotation at class level
* **Verification**: JMH benchmark performance improvement confirmed

**Native Image Compiler Optimization**:

* **Status**: ‚úÖ Implemented and verified  
* **Impact**: Additional performance improvement
* **Configuration**: `-O2` compiler flag in native build args
* **Verification**: Benchmark performance improvement confirmed

=== ‚ùå Failed Optimization Attempts

**Epsilon GC (No-Op Garbage Collector)**:

* **Status**: ‚ùå Failed - Fundamental incompatibility
* **Root Cause**: JWT validation creates 10MB+/second allocation rate
* **Reason**: Epsilon GC performs zero garbage collection, making failure mathematically inevitable
* **Outcome**: Reverted to Serial GC with documented analysis

**Memory Limit Optimizations**:

* **Status**: ‚ùå Limited benefit
* **Testing**: 48MB, 64MB, 80MB memory limits tested
* **Outcome**: <90% memory utilization acceptable for optimization testing
* **Result**: Focus shifted to CPU-bound optimizations

== See Also

* xref:jfr-analysis-findings.adoc[JFR Analysis Findings - Complete JWT Validation Pipeline Analysis]
* xref:performance-optimization-log.adoc[Performance Optimization Log - Detailed Optimization Attempt Records]
* xref:jwt-validation-performance-comparison.adoc[JWT Validation Performance Comparison - Baseline Performance Analysis]
* xref:JFR-Profiling-Guide.adoc[JFR Profiling Guide - Performance Analysis and Monitoring Setup]
* xref:Quarkus-Native-Optimization-Guide.adoc[Quarkus Native Optimization Guide - Build Configuration and Optimization]