= Developer Guide for cui-jwt-validation
:toc: left
:toclevels: 3
:sectnums:

This guide provides information for developers extending or integrating with the cui-jwt-validation library.

== Performance Metrics Infrastructure

The library includes a lightweight, thread-safe performance monitoring system in the `de.cuioss.jwt.validation.metrics` package for analyzing JWT validation performance.

=== TokenValidatorMonitor and MetricsTicker

`TokenValidatorMonitor` measures execution times for different JWT validation pipeline stages with microsecond precision using the `MetricsTicker` abstraction:

[source,java]
----
// Create monitor with default window size (100 samples)
TokenValidatorMonitor monitor = new TokenValidatorMonitor();

// Create a ticker for a specific measurement type
MetricsTicker ticker = MetricsTickerFactory.createTicker(MeasurementType.SIGNATURE_VALIDATION, monitor);

// Start recording
ticker.startRecording();
// ... perform signature validation ...
// Stop and record the measurement
ticker.stopAndRecord();

// Get average for analysis
Duration avgSignatureTime = monitor.getAverageDuration(MeasurementType.SIGNATURE_VALIDATION);
----

The `MetricsTicker` interface provides a clean abstraction that supports both active monitoring and no-op implementations to minimize overhead when metrics are disabled.

=== MeasurementType

The `MeasurementType` enum defines measurable pipeline stages:

* `COMPLETE_VALIDATION` - End-to-end validation time
* `TOKEN_PARSING` - JWT structure validation and decoding
* `HEADER_VALIDATION` - Header claims validation
* `SIGNATURE_VALIDATION` - Cryptographic verification (typically most expensive)
* `CLAIMS_VALIDATION` - Token claims validation
* `JWKS_OPERATIONS` - Key loading and caching operations

=== Design Principles

* **Lock-free operations** - Uses atomic operations for minimal overhead
* **Rolling window sampling** - Maintains configurable number of recent measurements
* **Microsecond precision** - High-resolution timing for accurate analysis
* **Framework-agnostic** - No external dependencies, can integrate with Micrometer/Prometheus

== Security Event Monitoring

The `SecurityEventCounter` in `de.cuioss.jwt.validation.security` provides thread-safe counters for security events:

[source,java]
----
SecurityEventCounter counter = tokenValidator.getSecurityEventCounter();

// Get current counts
long invalidTokens = counter.getCount(EventType.INVALID_JWT_FORMAT);
Map<EventType, Long> allCounts = counter.getCounters();

// Reset counters if needed
counter.reset(EventType.INVALID_JWT_FORMAT);
----

Event types are categorized by `EventCategory`:

* `INVALID_STRUCTURE` - Malformed tokens, size violations
* `INVALID_SIGNATURE` - Signature verification failures
* `SEMANTIC_ISSUES` - Expired tokens, audience mismatches

== Custom Claim Mapping

To handle non-standard token claims, implement custom `ClaimMapper` instances:

[source,java]
----
// Create custom mapper for non-standard "role" claim
ClaimMapper roleMapper = new JsonCollectionMapper();

IssuerConfig issuerConfig = IssuerConfig.builder()
    .issuerIdentifier("https://issuer.com")
    .jwksContent(jwksContent)
    .claimMapper("role", roleMapper)  // Register custom mapper
    .build();
----

Built-in mappers include:

* `JsonCollectionMapper` - Handles JSON arrays and strings
* `StringSplitterMapper` - Splits delimited strings
* `IdentityMapper` - Returns values unchanged

== Integration Points

=== Pipeline Customization

The validation pipeline consists of:

. `NonValidatingJwtParser` - Basic JWT parsing
. `TokenHeaderValidator` - Header validation
. `TokenSignatureValidator` - Signature verification
. `TokenClaimValidator` - Claims validation

Each validator throws `TokenValidationException` with specific `EventType` on failure.

== Testing Support

The library provides comprehensive test utilities via the `generators` artifact. See xref:UnitTesting.adoc[Unit Testing Guide] for details.

== Thread Safety

* `TokenValidator` is thread-safe after construction
* `SecurityEventCounter` uses atomic operations
* `TokenValidatorMonitor` uses lock-free ring buffers
* JWKS loaders handle concurrent key refresh

== Performance Considerations

* Signature validation typically consumes 90%+ of validation time
* Use `TokenValidatorMonitor` to identify bottlenecks
* Configure appropriate JWKS refresh intervals (300-3600 seconds)
* Consider using the built-in access token cache (see README for configuration)

=== Metrics Precision Notes

Some validation operations execute in sub-microsecond time and may appear as zero when exported:

* `TOKEN_FORMAT_CHECK` - Simple `String.isBlank()` check, typically < 1000ns
* `ISSUER_EXTRACTION` - `Optional.get()` from decoded JWT, typically < 1000ns
* `JWKS_OPERATIONS` - May show as 0 if keys are cached; actual JWKS fetches occur within signature validation

When these nanosecond measurements are converted to milliseconds for JSON export, they round to 0. This is expected behavior for extremely fast operations and does not indicate missing measurements.

== Memory Management

Configure limits in `ParserConfig` to prevent attacks:

* `maxTokenSize` - Limits entire JWT token (default 8KB)
* `maxPayloadSize` - Limits decoded parts (default 2KB)
* `maxStringSize` - Limits JSON strings (default 1KB)
* `maxArraySize` - Limits array elements (default 64)
* `maxDepth` - Limits JSON nesting (default 10)

== Related Documentation

* xref:../README.adoc[README] - Usage examples and configuration
* xref:../../doc/specification/technical-components.adoc[Technical Components] - Architecture details
* xref:UnitTesting.adoc[Unit Testing Guide] - Test utilities documentation