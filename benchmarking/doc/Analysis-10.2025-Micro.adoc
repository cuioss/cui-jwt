= JWT Library Performance Analysis (Micro-Benchmarks)
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js


== Executive Summary

JMH micro-benchmark testing of the core JWT validation library shows:

* **Core Validation**: 108,400 ops/s (in-memory, no HTTP overhead)
* **Error Handling (0% errors)**: 145,200 ops/s (validation succeeds)
* **Error Handling (50% errors)**: 225,200 ops/s (fast-fail on invalid tokens)
* **Validation Latency**: P50=53Âµs, P95=79Âµs, P99=116Âµs
* **Signature Validation**: P50=45Âµs (dominant cost in validation pipeline)
* **Library Performance**: 5x faster than integration tests (108k vs 21k ops/s)

== JMH Benchmark Configuration

=== Test Environment

* **Tool**: JMH 1.37 (Java Microbenchmark Harness)
* **JVM**: OpenJDK 21.0.7 (Temurin), aarch64 (Apple M4)
* **Threads**: 100 concurrent threads
* **Iterations**: 5 measurement + 3 warmup
* **Duration**: 4 seconds per iteration
* **Mode**: Throughput (ops/s) and Average Time (Âµs/op)

=== Benchmark Suite

[cols="2,3", options="header"]
|===
|Benchmark
|Description

|SimpleCoreValidationBenchmark
|Core JWT validation performance (throughput and latency)

|SimpleErrorLoadBenchmark
|Error handling with 0% and 50% invalid token rates

|jwt-validation-metrics
|Detailed breakdown of validation pipeline steps
|===

== Performance Results

=== Throughput Benchmarks

[cols="2,2,2,2", options="header"]
|===
|Benchmark
|Throughput
|Latency (avg)
|Configuration

|Core Validation
|108,400 ops/s
|644 Âµs/op
|100 threads, valid tokens

|Error Load (0% errors)
|145,200 ops/s
|N/A
|100 threads, all valid

|Error Load (50% errors)
|225,200 ops/s
|N/A
|100 threads, 50% invalid

|Concurrent Validation
|N/A
|658 Âµs/op
|100 threads, concurrent
|===

**Key Findings:**

* **Error handling improves throughput**: Fast-fail on invalid tokens (50% error rate) achieves 225k ops/s (+108% vs baseline)
* **All-valid scenario**: 145k ops/s when all tokens are valid (+34% vs core validation)
* **Latency consistency**: 644-658Âµs average time across different concurrency patterns

=== Validation Pipeline Breakdown

Based on `jwt-validation-metrics.json` (1,024 samples):

[cols="2,2,2,2", options="header"]
|===
|Step
|P50 Latency
|P95 Latency
|P99 Latency

|**Complete Validation**
|**53 Âµs**
|**79 Âµs**
|**116 Âµs**

|Signature Validation
|45 Âµs
|68 Âµs
|109 Âµs

|Token Parsing
|3.1 Âµs
|4.6 Âµs
|5.3 Âµs

|Token Building
|1.7 Âµs
|3.1 Âµs
|3.7 Âµs

|Claims Validation
|0.7 Âµs
|1.2 Âµs
|1.3 Âµs

|Cache Operations
|0.1 Âµs
|0.3-0.8 Âµs
|0.6-1.0 Âµs

|Issuer Resolution
|0.0 Âµs
|0.2 Âµs
|0.3 Âµs

|Header Validation
|0.1 Âµs
|0.3 Âµs
|0.3 Âµs
|===

**Analysis:**

* **Signature validation dominates**: 45Âµs (85% of total 53Âµs) - cryptographic operations are the bottleneck
* **Parsing overhead**: 3.1Âµs (6%) - JSON parsing and token extraction
* **Cache efficiency**: 0.1Âµs - lock-free cache adds negligible overhead
* **Claims validation**: 0.7Âµs - audience, expiration, issuer checks are fast
* **Total overhead**: ~8Âµs for non-cryptographic operations (parsing, claims, cache, issuer resolution)

== Performance Analysis

=== Library vs Integration Performance Gap

**Observation:** Library micro-benchmarks achieve 108k ops/s while integration tests (WRK) show 21k ops/s.

**Gap Analysis:**

[cols="2,2,3", options="header"]
|===
|Factor
|Impact
|Explanation

|Network Overhead
|10-15 Âµs
|HTTP request/response processing, Docker bridge networking

|Quarkus Stack
|5-10 Âµs
|REST framework, CDI injection, interceptors, context handling

|Native Compilation
|Minimal
|Native executable reduces startup, not per-request overhead

|**Total Gap**
|**~87k ops/s**
|**Pure library: 108k ops/s; Integration: 21k ops/s**
|===

**Conclusion:** The 5x performance difference is primarily due to HTTP/REST overhead. The core library validation is highly optimized at 108k ops/s.

=== Bottleneck Identification

**Primary Bottleneck: Cryptographic Signature Validation** ðŸŽ¯

* **Signature validation**: 45Âµs P50 (85% of validation time)
* **Algorithm**: RSA-256 signature verification (asymmetric cryptography)
* **Not optimizable**: Cryptographic operations are computationally intensive by design

**Secondary Costs:**

1. **Token parsing**: 3.1Âµs (JSON deserialization)
2. **Object construction**: 1.7Âµs (AccessTokenContent building)
3. **Claims validation**: 0.7Âµs (date checks, audience, issuer)
4. **Cache operations**: 0.1Âµs (negligible with lock-free design)

=== Error Handling Performance

**Fast-Fail Optimization:**

* **50% invalid tokens**: 225k ops/s (+108% throughput)
* **Early rejection**: Invalid tokens fail at signature validation without full parsing
* **Production benefit**: Real-world scenarios with invalid tokens see improved throughput

**Error Distribution:**

* Expired tokens: Detected in claims validation (0.7Âµs)
* Invalid signatures: Fail at signature validation (45Âµs)
* Malformed tokens: Fail at parsing (3.1Âµs)

== Comparison: Micro vs Integration

[cols="2,2,2,3", options="header"]
|===
|Metric
|Micro (Library)
|Integration (WRK)
|Difference

|Throughput
|108,400 ops/s
|21,600 ops/s
|**5x faster** (library)

|Latency P50
|53 Âµs
|6,300 Âµs
|**119x faster** (library)

|Latency P99
|116 Âµs
|39,380 Âµs
|**340x faster** (library)

|Environment
|In-memory JMH
|HTTP/Docker/Quarkus
|Network + framework overhead
|===

**Key Takeaway:** The core library is extremely fast (53Âµs P50). Integration overhead (HTTP, REST framework) adds ~6ms, which is acceptable for real-world HTTP-based microservices.

== Conclusion

Comprehensive JMH micro-benchmark analysis reveals:

* **Excellent library performance**: 108k ops/s with 53Âµs P50 latency demonstrates highly optimized JWT validation
* **Signature validation dominates**: 85% of validation time (45Âµs) spent in cryptographic operations (expected and unavoidable)
* **Minimal overhead**: Non-cryptographic operations (parsing, cache, claims) add only ~8Âµs (15% of total)
* **Fast-fail optimization**: 50% invalid token rate improves throughput to 225k ops/s
* **Integration reality check**: 5x performance gap between library (108k ops/s) and integration (21k ops/s) is due to HTTP/REST overhead, not library inefficiency
* **Production readiness**: Library meets performance requirements with sub-100Âµs validation latency

**Recommendation:** Current library performance is excellent. Further optimization would require algorithmic changes to signature validation (e.g., EdDSA instead of RSA), which is outside the scope of this library.
