= JWT Token Handling Security
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

xref:../Specification.adoc[Back to Main Specification]

== Overview
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-8[OAUTH-SHERIFF-8: Security] and xref:../security/Threat-Model.adoc[Threat Model]_

This document provides detailed specifications for the security aspects of the JWT Token Validation library.

=== Document Navigation

* xref:../../README.adoc[README] - Project overview and introduction
* xref:../../oauth-sheriff-core/README.adoc[Usage Guide] - How to use the library with code examples
* xref:../Requirements.adoc[Requirements] - Functional and non-functional requirements
* xref:../Specification.adoc[Specification] - Technical specifications
* xref:../LogMessages.adoc[Log Messages] - Reference for all log messages
* xref:../Build.adoc[Building and Development] - Information for contributors
* xref:../specification/technical-components.adoc[Technical Components] - Implementation details
* xref:../specification/testing.adoc[Testing] - Testing approach and coverage
* xref:../specification/token-size-validation.adoc[Token Size Validation] - Token size validation details
* xref:../specification/jwks-size-recommendations.adoc[JWKS Size Recommendations] - JWKS size limits and recommendations
* xref:../specification/token-decryption.adoc[Token Decryption] - Future JWE support
* xref:jwt-security-best-practices.adoc[JWT Security Best Practices Guide] - Comprehensive guide on JWT security best practices

== Security Measures

This section outlines the security measures implemented in the JWT Token Validation library.

=== Document Structure and Cross-References

* For a comprehensive analysis of common JWT vulnerabilities and attacks, see the xref:jwt-attacks-analysis.adoc[JWT Vulnerabilities and Attacks Analysis] document.
* For a comprehensive analysis of OAuth-related security vulnerabilities, see the xref:oauth-security-analysis.adoc[OAuth Security Considerations Analysis] document.
* For application-level security guidance and best practices, see the xref:jwt-security-best-practices.adoc[JWT Security Best Practices Guide].

The sections below focus on the technical implementation details of security measures in the library.

=== JWT Attack Mitigations

This section details how the library mitigates common JWT attack vectors as documented in the PentesterLab article "The Ultimate Guide to JWT Vulnerabilities and Attacks" (https://pentesterlab.com/blog/jwt-vulnerabilities-attacks-guide). The following table summarizes the attack vectors and the library's mitigation approaches:

[cols="1,2,2,2", options="header"]
|===
|Attack Vector |Description |Mitigation Approach |Test Coverage
|1. Signature Not Verified |Application fails to verify token signature, allowing forged claims |The library enforces signature verification through the `TokenValidator` pipeline; direct token decoding without verification is not exposed in the public API |link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenSignatureValidatorTest.java[TokenSignatureValidatorTest]
|2. None Algorithm Attack |Attacker modifies token to use `alg: none` to bypass signature verification |Explicit rejection of the "none" algorithm in `TokenSignatureValidator` and `SignatureAlgorithmPreferences` |link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/pipeline/TokenSignatureValidatorAlgorithmTest.java[TokenSignatureValidatorAlgorithmTest]
|3. Trivial Secret (Weak HMAC Keys) |Use of weak, guessable, or hardcoded HMAC shared secrets |Preference for asymmetric algorithms (RSA, ECDSA); explicit rejection of HMAC algorithms in default configuration; support for key rotation |link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/security/SignatureAlgorithmPreferencesTest.java[SignatureAlgorithmPreferencesTest], link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/security/KeyDisclosureVulnerabilityTest.java[KeyDisclosureVulnerabilityTest]
|4. Algorithm Confusion (RSA to HMAC) |Exploiting mismatched algorithm validation to trick servers into using wrong algorithm |Algorithm enforcement at configuration level; explicit key type validation; no auto-selection of algorithms based on token header |link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenSignatureValidatorTest.java[TokenSignatureValidatorTest]
|5. `kid` Injection (Key ID Manipulation) |Manipulation of the `kid` header parameter to inject malicious commands or paths |Validation and sanitization of `kid` values; pre-loading and caching of keys; abstracted key management through `JwksLoader` |link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/security/KeyInjectionAttackTest.java[KeyInjectionAttackTest]
|6. Embedded JWK (CVE-2018-0114) |Including attacker-controlled public keys in the token header |Rejection of keys from the token itself; ignoring the `jwk` header during validation; loading keys only from trusted sources |link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/security/EmbeddedJwkAttackTest.java[EmbeddedJwkAttackTest]
|7. JKU / X5U Header Abuse |Using attacker-controlled URLs in `jku` or `x5u` headers to perform SSRF |Ignoring `jku` and `x5u` headers; configuring JWKS URLs at initialization time; allowlist approach for JWKS sources |link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/security/JkuX5uAttackTest.java[JkuX5uAttackTest]
|8. CVE-2022-21449 (Psychic Signature) |Bypassing ECDSA signature verification using zero values |Using standard JDK cryptographic providers with proper ECDSA parameter validation; signature format validation |link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/security/PsychicSignatureAttackTest.java[PsychicSignatureAttackTest]
|===

[[signature-not-verified]]
==== 1. Signature Not Verified

The JWT validation library enforces signature verification through its architecture:

* The `TokenValidator` class is the entry point for all token processing and enforces the validation pipeline
* `TokenSignatureValidator` is a mandatory component in this pipeline
* The public API does not expose methods for token decoding without verification
* Internal `NonValidatingJwtParser` is only used as part of the validation pipeline, never exposed directly

Test coverage is provided by `TokenSignatureValidatorTest`, which verifies:

* Valid signatures are accepted
* Invalid signatures are rejected
* Algorithm confusion attacks are detected and prevented

[[none-algorithm-attack]]
==== 2. None Algorithm Attack

The library explicitly rejects the "none" algorithm through:

* Specific logic in `TokenSignatureValidator` to reject tokens with `alg: none`
* A validation approach that ensures algorithm validation occurs before token processing
* `SignatureAlgorithmPreferences` class that explicitly excludes the "none" algorithm from the allowed list

Test coverage is provided by `TokenSignatureValidatorAlgorithmTest`, which verifies rejection of tokens using the "none" algorithm.

[[trivial-secret]]
==== 3. Trivial Secret (Weak HMAC Keys)

The library protects against weak HMAC keys through:

* Preference for asymmetric algorithms (RSA, ECDSA) which don't rely on shared secrets
* Explicit rejection of HMAC algorithms in the default configuration
* Isolation of key material in dedicated handler classes
* Support for key rotation to limit the impact of potential key compromise

Test coverage is provided by `SignatureAlgorithmPreferencesTest` and `KeyDisclosureVulnerabilityTest`, which verify the library's protection against weak keys and key disclosure.

[[algorithm-confusion]]
==== 4. Algorithm Confusion (RSA to HMAC)

The library prevents algorithm confusion attacks through:

* Enforcing algorithms at the configuration level
* Separating token parsing from verification logic
* Avoiding auto-selection of algorithms based on token headers
* Explicitly validating key types

Test coverage is provided by `TokenSignatureValidatorTest`, which includes specific tests for algorithm confusion protection.

[[kid-injection]]
==== 5. `kid` Injection (Key ID Manipulation)

The library mitigates key ID injection attacks through:

* Validation and sanitization of `kid` values
* Avoiding direct file or database lookups based on the `kid` value
* Abstracting key management through the `JwksLoader` interface
* Pre-loading and caching keys to limit the impact of manipulated `kid` values

Test coverage is provided by `KeyInjectionAttackTest`, which includes comprehensive tests for various KID injection techniques including path traversal, SQL injection, null byte injection, command injection, and DoS attacks.

[[embedded-jwk]]
==== 6. Embedded JWK (CVE-2018-0114)

The library prevents embedded JWK attacks through:

* Rejecting keys provided in the token itself
* Ignoring the `jwk` header during validation
* Loading keys only from trusted sources configured at initialization time

Test coverage is provided by `EmbeddedJwkAttackTest`, which verifies the rejection of tokens with embedded JWK in the header.

[[jku-x5u-header-abuse]]
==== 7. JKU / X5U Header Abuse

The library prevents JKU and X5U header abuse through:

* Ignoring `jku` and `x5u` headers in tokens
* Configuring JWKS URLs at initialization time only
* Using an allowlist approach for JWKS sources in the `HttpJwksLoader` class

Test coverage is provided by `JkuX5uAttackTest`, which verifies the rejection of tokens with JKU or X5U headers pointing to malicious URLs.

[[psychic-signature]]
==== 8. CVE-2022-21449 (Psychic Signature)

The library protects against the "Psychic Signature" vulnerability through:

* Using standard JDK cryptographic providers with Java 21, which includes fixes for this vulnerability
* Validating ECDSA parameters during key validation
* Verifying signature formats before performing verification

Test coverage is provided by `PsychicSignatureAttackTest`, which verifies the rejection of tokens with all-zero ECDSA signatures for ES256, ES384, and ES512 algorithms.

=== Signature Validation
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-1.3[OAUTH-SHERIFF-1.3: Signature Validation]_

==== Status: IMPLEMENTED

The following classes implement this specification:

* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenSignatureValidator.java[TokenSignatureValidator]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/TokenValidator.java[TokenValidator]

The following tests verify the implementation:

* link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenSignatureValidatorTest.java[TokenSignatureValidatorTest] - Comprehensive tests for signature validation, including:
** Validation of tokens with supported algorithms (RS256)
** Rejection of tokens with unsupported algorithms (HS256, HS384, HS512, none)
** Protection against algorithm confusion attacks
* link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/TokenValidatorTest.java[TokenValidatorTest] - Tests for the TokenValidator class

The library supports the following signature algorithms as specified in the requirements:

==== Supported Algorithms

* RS256 (RSASSA-PKCS1-v1_5 using SHA-256)
* RS384 (RSASSA-PKCS1-v1_5 using SHA-384)
* RS512 (RSASSA-PKCS1-v1_5 using SHA-512)
* PS256 (RSASSA-PSS using SHA-256 and MGF1 with SHA-256)
* PS384 (RSASSA-PSS using SHA-384 and MGF1 with SHA-384)
* PS512 (RSASSA-PSS using SHA-512 and MGF1 with SHA-512)
* ES256 (ECDSA using P-256 and SHA-256)
* ES384 (ECDSA using P-384 and SHA-384)
* ES512 (ECDSA using P-521 and SHA-512)

==== Rejected Algorithms

The following algorithms are explicitly rejected for security reasons:

* HS256 (HMAC using SHA-256)
* HS384 (HMAC using SHA-384)
* HS512 (HMAC using SHA-512)
* None (Unsecured JWT)

Refer to the implementation and associated JavaDoc for detailed behavior.

=== Token Size Limits
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-8.1[OAUTH-SHERIFF-8.1: Token Size Limits]_

==== Status: IMPLEMENTED

To prevent denial of service attacks, the library enforces a maximum token size of 8KB.

For detailed information about token size validation, including implementation details, usage examples, and testing strategy, please refer to the xref:../specification/token-size-validation.adoc[Token Size Validation] document.

=== Safe Parsing
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-8.2[OAUTH-SHERIFF-8.2: Safe Parsing]_

==== Status: IMPLEMENTED

The following classes implement this specification:

* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/NonValidatingJwtParser.java[NonValidatingJwtParser]

The `NonValidatingJwtParser` class provides comprehensive safe parsing features to protect against common attacks such as memory exhaustion, stack overflow, and malformed input attacks.

For implementation details, see the JavaDoc of the link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/NonValidatingJwtParser.java[NonValidatingJwtParser] class.

The following tests verify the implementation:

* link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/pipeline/NonValidatingJwtParserTest.java[NonValidatingJwtParserTest] - Comprehensive tests for the NonValidatingJwtParser class, including:
** Token size validation tests
** JSON depth limit tests
** Large JSON array handling tests
** Large JSON string handling tests
** DSL-JSON parser caching tests

These security measures protect against common attacks such as memory exhaustion, stack overflow, and malformed input attacks.

=== JWKS Size Limits
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-8.1[OAUTH-SHERIFF-8.1: Token Size Limits] and link:../Requirements.adoc#OAUTH-SHERIFF-8.2[OAUTH-SHERIFF-8.2: Safe Parsing]_

==== Status: IMPLEMENTED

The following classes implement this specification:

* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/key/JWKSKeyLoader.java[JWKSKeyLoader]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/ParserConfig.java[ParserConfig]

To prevent denial of service attacks and memory exhaustion, the library enforces size limits on JWKS content. Based on research of typical JWKS sizes from major identity providers and industry standards, a default upper bound of 64 KB is recommended.

The `JWKSKeyLoader` class checks the size of JWKS content against the maximum payload size configured in `ParserConfig` before parsing. If the content exceeds the limit, it logs a warning and returns an empty result.

For detailed information about JWKS size recommendations, including analysis of typical JWKS content sizes, industry standards, and implementation recommendations, please refer to the xref:../specification/jwks-size-recommendations.adoc[JWKS Size Recommendations] document.

=== Claims Validation
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-8.4[OAUTH-SHERIFF-8.4: Claims Validation]_

==== Status: IMPLEMENTED

The following classes implement this specification:

* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenClaimValidator.java[TokenClaimValidator]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenHeaderValidator.java[TokenHeaderValidator]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/IssuerConfig.java[IssuerConfig]

The library provides comprehensive validation for standard JWT claims as defined in RFC 7519.

==== Required Claims

* Issuer (iss) - validated by TokenHeaderValidator
* Subject (sub) - validated by TokenClaimValidator
* Expiration Time (exp) - validated by TokenClaimValidator
* Issued At (iat) - validated by TokenClaimValidator
* Not Before (nbf) - validated by TokenClaimValidator if present
* Audience (aud) - validated by TokenClaimValidator if expected audience is provided
* Authorized Party (azp) - validated by TokenClaimValidator if expected client ID is provided

For implementation details, see the JavaDoc of the link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenClaimValidator.java[TokenClaimValidator] and link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenHeaderValidator.java[TokenHeaderValidator] classes.

=== Secure Communication
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-8.3[OAUTH-SHERIFF-8.3: Secure Communication]_

==== Status: IMPLEMENTED

The following classes implement this specification:

* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/http/HttpJwksLoader.java[HttpJwksLoader]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/security/SecureSSLContextProvider.java[SecureSSLContextProvider]

The library ensures secure communication for key retrieval by requiring TLS 1.2 or higher by default. The `SecureSSLContextProvider` class is an instance class that allows configuration of the minimum TLS version to be used. The `HttpJwksLoader` uses a builder pattern for creation, with the `SecureSSLContextProvider` instance as an optional parameter.

For implementation details, see the JavaDoc of the link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/http/HttpJwksLoader.java[HttpJwksLoader] and link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/security/SecureSSLContextProvider.java[SecureSSLContextProvider] classes.

Integration tests verify the implementation by connecting to a Keycloak server using HTTPS.

=== Cryptographic Agility
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-8.5[OAUTH-SHERIFF-8.5: Cryptographic Agility]_

==== Status: IMPLEMENTED

The following classes implement this specification:

* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/security/SignatureAlgorithmPreferences.java[AlgorithmPreferences]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/security/JwkKeyHandler.java[JwkKeyHandler]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/key/KeyInfo.java[KeyInfo]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/JwksLoader.java[JwksLoader]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/key/JWKSKeyLoader.java[JWKSKeyLoader]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenSignatureValidator.java[TokenSignatureValidator]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/IssuerConfig.java[IssuerConfig]

The cryptographic agility features include:

1. Support for multiple signature algorithms (RSA, ECDSA, RSA-PSS)
2. Configuration of preferred algorithms through IssuerConfig
3. Key rotation and algorithm migration capabilities
4. Storage of algorithm information with keys
5. Selection of keys based on algorithm preferences
6. Isolation of low-level cryptographic operations in a dedicated handler class

For implementation details, see the JavaDoc of the following classes:

* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/security/SignatureAlgorithmPreferences.java[AlgorithmPreferences]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/security/JwkKeyHandler.java[JwkKeyHandler]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/key/KeyInfo.java[KeyInfo]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/JwksLoader.java[JwksLoader]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/key/JWKSKeyLoader.java[JWKSKeyLoader]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenSignatureValidator.java[TokenSignatureValidator]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/IssuerConfig.java[IssuerConfig]

The following tests verify the implementation:

* link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/security/JwkKeyHandlerTest.java[JwkKeyHandlerTest] - Comprehensive tests for the JwkKeyHandler class, including:
** Parsing and validation of RSA keys
** Validation of EC key fields
** Base64 URL encoding validation
** Security tests for potential attacks
* link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/jwks/key/JWKSKeyLoaderTest.java[JWKSKeyLoaderTest] - Tests for the JWKSKeyLoader
* link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenSignatureValidatorTest.java[TokenSignatureValidatorTest] - Tests for the TokenSignatureValidator

=== Security Events Monitoring
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-7.3[OAUTH-SHERIFF-7.3: Security Events]_

==== Status: IMPLEMENTED

The following classes implement this specification:

* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/security/SecurityEventCounter.java[SecurityEventCounter]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/TokenValidator.java[TokenValidator]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/TokenBuilder.java[TokenBuilder]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenClaimValidator.java[TokenClaimValidator]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenHeaderValidator.java[TokenHeaderValidator]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenSignatureValidator.java[TokenSignatureValidator]
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/NonValidatingJwtParser.java[NonValidatingJwtParser]

The library provides a mechanism to monitor and count security events that occur during token processing. This allows applications to track potential security issues and anomalies without duplicating logging functionality.

==== Features

* Thread-safe counter implementation for high concurrency environments
* Consistent event naming scheme aligned with JWTTokenLogMessages
* Support for all relevant security events (token validation failures, signature issues, etc.)
* Reset capability for counters (both individual and all counters)
* Designed for future integration with metrics systems like Micrometer
* Fine-grained event tracking at each step of the token processing pipeline

==== Usage

The SecurityEventCounter is integrated with TokenValidator and accessible via a getter method. Applications can:

1. Retrieve the counter from TokenValidator using `getSecurityEventCounter()`
2. Get counts for specific event types using `getCount(EventType)`
3. Get a snapshot of all counters using `getCounters()`
4. Reset individual counters using `reset(EventType)`
5. Reset all counters using `reset()`

This allows applications to monitor security events and take appropriate actions based on the counts.

==== Integration with Flow Elements

The SecurityEventCounter is passed to all flow elements in the token processing pipeline:

* TokenBuilder - Counts events during token creation
* TokenClaimValidator - Counts claim validation failures (missing claims, audience mismatch, etc.)
* TokenHeaderValidator - Counts header validation failures (algorithm issues, issuer mismatch)
* TokenSignatureValidator - Counts signature validation failures (key not found, invalid signatures)
* NonValidatingJwtParser - Counts token parsing failures (format issues, size limits)

This provides a more granular view of security events, allowing for better monitoring and troubleshooting.

==== Event Types and Categories

The SecurityEventCounter.EventType enum defines all countable security events, including:

* Token format issues (empty tokens, size exceeded, decoding failures)
* Missing claims (required claims, recommended elements)
* Validation failures (token expired, future tokens, audience mismatch)
* Signature issues (validation failures, key not found)
* Algorithm issues (unsupported algorithms, rejected algorithms)
* JWKS issues (fetch failures, parse failures)
* Critical security issues (security breaches, violations)

Each EventType is associated with an EventCategory that classifies the type of validation failure:

* InvalidStructure: For malformed tokens, size violations, etc. (typically thrown by NonValidatingJwtParser or TokenHeaderValidator)
* InvalidSignature: For signature verification failures (typically thrown by TokenSignatureValidator)
* SemanticIssues: For semantic validation failures (typically thrown by TokenClaimValidator, e.g., time or audience issues)

These categories help applications determine the appropriate response to validation failures, such as mapping to specific HTTP status codes or error messages.

==== Exception-based Error Handling

The library uses an exception-based approach for error handling through the TokenValidationException class. This runtime exception encapsulates:

* EventType - The type of security event that caused the validation failure
* EventCategory - The category of the validation failure
* A detailed error message

When a validation failure occurs, the appropriate component throws a TokenValidationException with the relevant EventType and message. This provides a structured way to handle validation failures and allows applications to:

1. Catch specific types of validation failures
2. Access detailed information about the failure
3. Map validation failures to appropriate HTTP status codes
4. Provide meaningful error messages to users

The TokenValidationException is integrated with the SecurityEventCounter, ensuring that all validation failures are properly counted and logged.

==== Bidirectional Links to Log Messages

Each EventType has a bidirectional link to its corresponding log message in JWTTokenLogMessages. This is implemented through the `getLogRecord()` method, which returns the appropriate LogRecord based on the event type's ID.

This bidirectional linking ensures:

1. Consistent error reporting between logs and metrics
2. Easy correlation between security events and log messages
3. Centralized management of security event definitions
4. Simplified troubleshooting by mapping event counts to specific log messages

For example, the TOKEN_EXPIRED event type (ID: 134) is linked to JWTTokenLogMessages.WARN.TOKEN_EXPIRED, ensuring that the same message template and identifier are used for both logging and event counting.

The following tests verify the implementation:

* link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/security/SecurityEventCounterTest.java[SecurityEventCounterTest] - Tests for the SecurityEventCounter class
* link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/TokenValidatorSecurityEventTest.java[TokenValidatorSecurityEventTest] - Tests for the integration with TokenValidator

=== Standard JDK Cryptographic Providers
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-8.5[OAUTH-SHERIFF-8.5: Cryptographic Agility]_

==== Status: IMPLEMENTED

The library uses standard JDK cryptographic providers for all cryptographic operations. This approach leverages the built-in cryptographic capabilities of Java 21+, providing excellent performance, security, and compatibility with GraalVM native image compilation.

==== Integration Points

The following classes use standard JDK providers:

* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/key/JwkKeyHandler.java[JwkKeyHandler] - Uses standard JDK for:
** Retrieving EC curve parameters via `AlgorithmParameters.getInstance("EC")`
** Supporting standard elliptic curves (P-256, P-384, P-521) using `ECGenParameterSpec`
** Converting JWK curve names to standard JDK curve specifications

* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenSignatureValidator.java[TokenSignatureValidator] - Uses standard JDK for:
** Signature verification of JWT tokens via `Signature.getInstance(algorithm)`
** Supporting all RFC 7518 signature algorithms:
*** RSA signatures (RS256, RS384, RS512)
*** ECDSA signatures (ES256, ES384, ES512)
*** RSA-PSS signatures (PS256, PS384, PS512)

==== Algorithm Support

All algorithms are supported by the standard JDK cryptographic providers in Java 21:

* **RSA algorithms**: Full support for RSA-PKCS1 (RS256/384/512) and RSA-PSS (PS256/384/512)
* **ECDSA algorithms**: Complete support for all standard curves (P-256, P-384, P-521)
* **Enhanced security**: Java 21 provides enhanced default key sizes and cryptographic hardening

==== Security Considerations

Using standard JDK providers provides several security benefits:

* **RFC 7518 Compliance**: Complete support for all standard JOSE algorithms
* **Enhanced Performance**: 3-4x faster RSA operations, 20x faster ECDSA operations vs external cryptographic libraries
* **Reduced Attack Surface**: No additional cryptographic library dependencies
* **Faster Security Updates**: Security patches delivered through JDK updates
* **Native Image Compatibility**: Excellent support for GraalVM native compilation
* **Java 21 Enhancements**: Larger default key sizes, post-quantum cryptography preparation

For implementation details, see the JavaDoc of the cryptographic classes.

== Additional OAuth/JWT Security Considerations

Based on research from https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html[OAuth Common Vulnerabilities (Doyensec, 2025)], this section addresses additional security considerations for JWT Token Validation in OAuth/OIDC scenarios. For a detailed analysis of each vulnerability and our mitigation approach, please refer to the xref:../security/oauth-security-analysis.adoc[OAuth Security Considerations Analysis] document.

=== Client Confusion Attack Prevention
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-8.4[OAUTH-SHERIFF-8.4: Claims Validation]_

==== Status: IMPLEMENTED

The client confusion attack occurs when a token issued for one client is used with a different client. This can lead to unauthorized access if the validation doesn't verify that the token was issued for the correct client.

==== Implementation

* The `TokenClaimValidator` class validates the `azp` (authorized party) claim, which identifies the client the token was issued for.
* The `IssuerConfig` class supports both audience (`aud`) and `azp` validation through configuration.
* Validation of both claims is configurable through the `IssuerConfig` builder:
  * `expectedAudience()` - sets the expected audience for validation
  * `expectedClientId()` - sets the expected client ID for `azp` claim validation

* For maximum security, both audience and client ID-Token should be enabled.

[source,java]
----
// Configure HTTP-based JWKS loading
HttpJwksLoaderConfig httpConfig = HttpJwksLoaderConfig.builder()
    .jwksUrl("https://issuer.example.com/.well-known/jwks.json")
    .refreshIntervalSeconds(60)
    .build();

// Create an issuer configuration with audience and client ID-Token
IssuerConfig issuerConfig = IssuerConfig.builder()
    .issuer("https://issuer.example.com")
    .expectedAudience("target-Audience")
    .expectedClientId("client-id")
    .httpJwksLoaderConfig(httpConfig)
    .build();

// Create the token validator
TokenValidator validator = TokenValidator.builder()
    .issuerConfig(issuerConfig)
    .build();
----

==== Security Note

To provide comprehensive protection against client confusion attacks, applications should:

1. Always include the `azp` claim in tokens issued for a specific client
2. Configure token validators to require `azp` validation
3. Consider making audience validation mandatory for all client applications

==== Test Specifications

1. **AZP Claim Validation Test**:
   * Create tokens with various `azp` claim values
   * Test validation with matching and non-matching client IDs
   * Verify tokens with non-matching `azp` values are rejected

2. **Client Confusion Attack Test**:
   * Create a token for Client A
   * Attempt to use it with Client B's configuration
   * Verify the token is rejected due to `azp` claim mismatch

=== Scope Upgrade Attack Prevention
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-8.4[OAUTH-SHERIFF-8.4: Claims Validation]_

==== Status: IMPLEMENTED

The scope upgrade attack occurs when an attacker attempts to add additional scopes during the token exchange process, potentially gaining unauthorized privileges.

==== Current Implementation

* The `ParsedAccessToken` class provides methods to verify token scopes through `getScopes()`, `providesScopes()`, and `determineMissingScopes()`.
* Scope validation is implemented at the application level, not as part of the token validation process.
* The final check whether the scopes are correct are to be in the client library.


== Security Testing Specifications

=== Client Confusion Attack Testing
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-12.1[OAUTH-SHERIFF-12.1: Security Testing]_

==== Test Cases

[cols="2,3,1,2", options="header"]
|===
|Test Case |Description |Expected Outcome |Implementation
|verify_audience_validation |Test token validation with valid audience claim |Success |link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/ClientConfusionAttackTest.java#L158[verify_audience_validation_without_azp]
|verify_audience_validation_failure |Test token validation with invalid audience claim |Failure |Not implemented yet
|verify_azp_validation |Test token validation with valid azp claim |Success |link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/ClientConfusionAttackTest.java#L58[verify_azp_validation]
|verify_azp_validation_failure |Test token validation with invalid azp claim |Failure |link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/ClientConfusionAttackTest.java#L114[verify_azp_validation_failure]
|verify_different_client_token_rejected |Test token from a different client ID is rejected |Failure |link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/ClientConfusionAttackTest.java#L136[verify_different_client_token_rejected]
|===

==== Implementation Requirements

* Test class link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/ClientConfusionAttackTest.java[ClientConfusionAttackTest] has been implemented
* Creates tokens with various client IDs and audience values
* Tests with different validators configured for specific clients
* Verifies cross-client token usage is rejected

== JWT Vulnerabilities and Attacks

=== Overview of Common JWT Vulnerabilities

The security of JWT token handling is critical for maintaining the integrity of authentication and authorization systems. Based on comprehensive research from https://pentesterlab.com/blog/jwt-vulnerabilities-attacks-guide[The Ultimate Guide to JWT Vulnerabilities and Attacks (PentesterLab, 2025)], this section addresses key vulnerabilities and how they are mitigated in our implementation.

For a detailed analysis of each vulnerability and our mitigation approach, please refer to the xref:../security/jwt-attacks-analysis.adoc[JWT Vulnerabilities and Attacks Analysis] document.

=== Key Vulnerabilities Addressed

1. **Signature Not Verified** - All tokens undergo mandatory signature verification in our pipeline architecture
2. **None Algorithm Attack** - The "none" algorithm is explicitly rejected
3. **Algorithm Confusion** - Algorithm enforcement prevents switching between RSA and HMAC
4. **Key ID Injection** - Strict validation prevents path traversal and injection attacks
5. **Embedded JWK Attack** - Keys from token headers are never trusted
6. **JKU/X5U Header Abuse** - External key URLs from tokens are ignored

[[oauth-security-considerations]]
=== OAuth Security Considerations

This section details how the library addresses OAuth-specific security considerations as documented in the Doyensec article "Common OAuth Vulnerabilities" (https://blog.doyensec.com/2025/01/30/oauth-common-vulnerabilities.html). The following table summarizes the vulnerabilities and the library's mitigation approaches:

[cols="1,2,2,2", options="header"]
|===
|Vulnerability |Description |Mitigation Approach |Test Coverage
|Client Confusion Attack |Using a token issued for one client with a different client |Validation of `azp` (authorized party) and `aud` (audience) claims; configuration through `IssuerConfig` builder |link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/ClientConfusionAttackTest.java[ClientConfusionAttackTest]
|Scope Upgrade Attack |Adding additional scopes during token exchange |`ParsedAccessToken` class provides methods to verify token scopes; scope validation guidance in documentation |No specific tests
|CSRF Attacks |Exploiting cross-site request forgery in OAuth flows |Out of scope for token validation library; documentation recommends using the `state` parameter |Out of scope
|Redirect Attacks |Manipulating redirect URIs to steal authorization codes |Out of scope for token validation library; documentation recommends proper redirect URI validation |Out of scope
|Mutable Claims Attack |Using changeable claims for user identification |Enforcing validation of the immutable `sub` claim; documentation recommends using `sub` for user identification |link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/pipeline/validator/TokenClaimValidatorTest.java[TokenClaimValidatorTest]
|Redirect Scheme Hijacking |Intercepting OAuth redirects in mobile apps |Out of scope for token validation library; documentation recommends using PKCE for mobile apps |Out of scope
|===

[[client-confusion-attack]]
==== 1. Client Confusion Attack

The library prevents client confusion attacks through:

* The `TokenClaimValidator` enforces validation of the `azp` (authorized party) claim
* The `IssuerConfig` class supports both audience (`aud`) and `azp` validation
* Configuration through the `IssuerConfig` builder:
** `expectedAudience()` - sets the expected audience
** `expectedClientId()` - sets the expected client ID for `azp` validation

Test coverage is provided by `ClientConfusionAttackTest`, which verifies:

* Tokens with valid `azp` claims are accepted
* Tokens with invalid `azp` claims are rejected
* Tokens from different clients are rejected
* Audience validation works correctly without `azp`
* `azp` validation works correctly without audience
* Tokens with missing `azp` claims are rejected when validation is enabled

[[scope-upgrade-attack]]
==== 2. Scope Upgrade Attack

The library provides tools to prevent scope upgrade attacks through:

* The `ParsedAccessToken` class provides methods to verify token scopes:
** `getScopes()` - retrieves the scopes from the token
** `providesScopes()` - checks if the token provides specific scopes
** `determineMissingScopes()` - identifies missing scopes
* The token validation process does not modify or upgrade scopes
* The library documentation recommends proper scope validation at the application level

This is an area where additional test coverage is planned.

==== 3. CSRF Attacks

CSRF protection during the OAuth flow is primarily a concern at the application level, not in the token validation library:

* The library focuses on token validation after the OAuth flow is complete
* The library documentation recommends using the `state` parameter for CSRF protection
* Implementing proper CSRF protection is the responsibility of the client application

==== 4. Redirect Attacks

Redirect URI validation is the responsibility of the authorization server, not the token validation library:

* The library operates after the OAuth flow is complete and tokens have been issued
* The library documentation recommends secure OAuth implementations including proper redirect URI validation
* The library provides guidance on detecting and preventing token hijacking attempts

[[mutable-claims-attack]]
==== 5. Mutable Claims Attack

The library mitigates mutable claims attacks through:

* The `TokenClaimValidator` enforces validation of the `sub` claim
* The library documentation strongly recommends using `sub` for user identification instead of mutable claims like email
* The library architecture encourages proper user identification practices

Test coverage is provided by `TokenClaimValidatorTest`, which verifies:

* Tokens with valid subject claims are accepted
* Tokens with missing subject claims are rejected
* Behavior with empty subject claims is documented
* Handling of mutable claims is tested

==== 6. Redirect Scheme Hijacking

Mobile app redirect scheme handling is outside the scope of the token validation library:

* The library focuses on token validation after the OAuth flow is complete
* The library documentation recommends using the Authorization Code flow with PKCE for mobile apps
* The library provides guidance on secure mobile OAuth implementations

=== Outstanding Security Tasks

Please refer to the link:../TODO.adoc[TODO] document for planned security enhancements and additional test coverage.

[[key-management]]
=== Key Management
_See Requirement xref:../Requirements.adoc#OAUTH-SHERIFF-4[OAUTH-SHERIFF-4: Key Management]_

==== Status: IMPLEMENTED

The library implements a robust key management system for handling cryptographic keys used in JWT validation.

==== Implementation Details

The key management system is implemented through the following classes:

* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/JwksLoader.java[JwksLoader] - Interface for loading JWKS (JSON Web Key Set)
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/http/HttpJwksLoader.java[HttpJwksLoader] - Implementation for loading JWKS from HTTP endpoints
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/file/FileSystemJwksLoader.java[FileSystemJwksLoader] - Implementation for loading JWKS from the file system
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/cache/CachedJwksLoader.java[CachedJwksLoader] - Implementation that adds caching to any JwksLoader
* link:../../oauth-sheriff-core/src/main/java/de/cuioss/sheriff/oauth/core/jwks/multi/MultiSourceJwksLoader.java[MultiSourceJwksLoader] - Implementation that aggregates multiple JwksLoader instances

The key management system supports:

* Automatic key rotation through JWKS refreshing
* Caching of keys to improve performance and resilience
* Multiple key sources for high availability
* Validation of key types and usage
* Protection against key injection attacks

==== Security Features

The key management system includes the following security features:

* Strict validation of key IDs (`kid`) to prevent injection attacks
* Sanitization of key material to prevent XSS and injection vulnerabilities
* Enforcement of key usage constraints (e.g., RSA keys for signature verification)
* Secure handling of JWKS retrieval with TLS validation
* Protection against embedded JWK attacks by only trusting pre-configured key sources
* Protection against JKU/X5U header abuse by ignoring these headers in tokens

==== Test Coverage

The key management system is thoroughly tested through:

* link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/jwks/http/HttpJwksLoaderTest.java[HttpJwksLoaderTest] - Tests for loading JWKS from HTTP endpoints
* link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/jwks/file/FileSystemJwksLoaderTest.java[FileSystemJwksLoaderTest] - Tests for loading JWKS from the file system
* link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/jwks/cache/CachedJwksLoaderTest.java[CachedJwksLoaderTest] - Tests for JWKS caching
* link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/jwks/multi/MultiSourceJwksLoaderTest.java[MultiSourceJwksLoaderTest] - Tests for multiple JWKS sources
* link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/security/KeyInjectionAttackTest.java[KeyInjectionAttackTest] - Tests for protection against key ID injection attacks
* link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/security/EmbeddedJwkAttackTest.java[EmbeddedJwkAttackTest] - Tests for protection against embedded JWK attacks
* link:../../oauth-sheriff-core/src/test/java/de/cuioss/sheriff/oauth/core/security/JkuX5uAttackTest.java[JkuX5uAttackTest] - Tests for protection against JKU/X5U header abuse
