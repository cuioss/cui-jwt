= JWT Integration Test Latency Optimization Plan
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Critical Build Information

**Build Commands:** 
```bash
# Run benchmarks with distroless containers (production testing)
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-benchmark -Pbenchmark-testing

# Run benchmarks with JFR profiling containers (performance analysis)
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-benchmark -Pbenchmark-jfr
```

**Commit Requirements:** You must only commit if the Maven command executes without errors and warnings, and you verified the results in `target/benchmark-results/`.

== Executive Summary

=== Current Performance Baseline (July 22, 2025)

**Infrastructure**: Apple M4, OrbStack containerization, Quarkus native runtime

|===
| Algorithm | P95 Latency | Throughput | Processing Overhead | Token Length | Provider | Status
| **RS256** | **143.0ms** | **1,533 req/sec** | **138.9ms** | 977 chars | BouncyCastle | âœ… CURRENT
| RS256 (Default JDK) | 173.0ms | 1,413 req/sec | 168.0ms | 977 chars | SUN | âšª BASELINE
| **Health Check** | **3.5ms** | **38,683 req/sec** | **0ms (baseline)** | N/A | N/A | âœ… BASELINE
|===

**Current Focus**: Reduce RS256 JWT validation latency from 143ms to <20ms through RSA-specific optimizations.

**Optimization Achievement**:
- BouncyCastle: 17% improvement (173ms â†’ 143ms)
- **Note**: -march=native optimization removed due to Docker portability concerns

=== Quick Performance Summary

**RS256 Performance**: 143.0ms P95 latency, 1,533 req/sec throughput (BouncyCastle)
**Target**: <20ms P95 latency (10ms achievable based on 5ms microbenchmark)
**Remaining Gap**: 123ms (86% improvement still needed)
**Bottleneck**: RSA signature verification (`BigInteger.modPow()` ~97% of time)

=== Infrastructure Optimization Status âœ… **COMPLETED**

**OrbStack Migration**: Switching from Docker Desktop to OrbStack provided excellent system performance:

- Health Check: 5.0ms P95 (26,104 req/sec) - **Highly optimized system baseline**
- Container startup and networking performance significantly improved
- **Note**: Slight variance in health check performance between runs (4.1-5.0ms)

== Performance Analysis Summary

=== JFR Analysis Results âœ… **COMPLETED**

**Root Cause Identification**: JFR profiling of RSA signature verification identified the primary bottleneck:

- **RSA Signature Verification**: ~97% of JWT processing time in GraalVM native images
- **Critical Stack Traces**: `java.math.BigInteger.modPow()` operations dominating CPU time
- **Evidence**: `sun.security.rsa.RSACore.crypt()` and `de.cuioss.jwt.validation.pipeline.TokenSignatureValidator.verifySignature()` as primary CPU consumers

**Performance Breakdown (RS256 with BouncyCastle)**:

- System Infrastructure: 4.1ms (networking, HTTP, Docker)
- RSA Signature Verification: ~134ms (BouncyCastle RSA operations)
- JWT Parsing/Validation: ~5ms (library logic - matches microbenchmark)
- **Total**: 143.0ms P95
- **Gap to Target**: 134ms RSA overhead must be reduced to <16ms
- **BouncyCastle Benefit**: 29ms RSA overhead reduction vs default JDK

=== Critical Findings

1. **System Baseline**: 3.5ms P95 (health check) - Infrastructure is highly optimized
2. **JWT Processing**: 137.9ms additional overhead for RS256 with BouncyCastle + -march=native
3. **BouncyCastle Impact**: 17% improvement over default JDK (173.0ms â†’ 143.0ms)
4. **RSA Bottleneck**: `BigInteger.modPow()` operations consume ~94% of JWT validation time
5. **Algorithm Migration Success**: ES256 â†’ RS256 improved performance by 71.7% (504.9ms â†’ 143.0ms)
6. **Provider Optimization Success**: SUN â†’ BouncyCastle improved performance by 17.3%

== Next Steps - Actionable Tasks

=== Priority 1: RSA Performance Optimization ðŸš€ **NEXT FOCUS**

**Goal**: Reduce RSA signature verification overhead from 134ms to target <16ms

**Current Status**: RS256 with BouncyCastle at 143.0ms P95 (1,533 req/sec)
**Microbenchmark Reference**: JWT library alone achieves 5ms - proving <10ms is possible
**BouncyCastle Benefit**: 17% improvement (29ms reduction) over default JDK provider

**Next Optimization Paths**:

1. **GraalVM Native Image Tuning** â­ **IMMEDIATE ACTION**:
+
[source,bash]
----
# Add to native image build
-march=native                    # ARM64 CPU-specific optimizations
-O2                             # Standard optimization level (default)
--pgo-instrument                # Generate PGO data
--pgo=profile.iprof            # Use PGO data for RSA hotpaths
----

2. **Java 24 + GraalNN Upgrade** (Optional - Oracle GraalVM Only):
+
[source,bash]
----
# Requires Oracle GraalVM for JDK 24
-O3                             # Enables GraalNN ML-powered profiler
----
+
   - **Expected**: 7.9% improvement (143ms â†’ ~132ms)
   - **Cost**: Migration to non-LTS Java 24
   - **Risk**: Limited benefit for RSA computational bottleneck
   - **Docker**: Use `amazoncorretto:24` base image

3. **BouncyCastle Provider** âœ… **COMPLETED**:
   - Integrated with 17% improvement (173ms â†’ 143ms)
   - 29ms RSA overhead reduction vs default JDK

4. **Production Monitoring Implementation** ðŸš€ **NEXT FOCUS**:
   - Library-agnostic metrics collection (similar to SecurityEventCounter pattern)
   - Pipeline step measurement for each JWT validation phase
   - Quarkus module integration with Micrometer translation layer
   - Real-world performance insights for production optimization

**Target Performance**: <20ms P95 (123ms improvement needed from current 143ms BouncyCastle baseline)

=== Priority 2: Production Monitoring Setup ðŸ“Š **REQUIRED**

**Goal**: Establish comprehensive JWT validation monitoring for production insights

**Implementation Tasks**:

1. **Micrometer Metrics Integration**:
+
[source,java]
----
@Timed(value = "jwt.validation.time", histogram = true)
@Counted(value = "jwt.validation.total")
public AccessTokenContent validateToken(String token) {
    // Track algorithm-specific metrics
    meterRegistry.counter("jwt.validation.algorithm", "type", algorithm).increment();
}
----

2. **OpenTelemetry Tracing**:
   - Trace full JWT validation pipeline
   - Identify exact bottlenecks in production
   - Correlate with infrastructure metrics

3. **Custom JFR Events** (for better native image profiling):
+
[source,java]
----
@Name("jwt.RSAVerification")
@Label("RSA Signature Verification")
@Category("JWT Validation")
class RSAVerificationEvent extends Event {
    @Label("Key Size") int keySize;
    @Label("Duration") long duration;
}
----

**Expected Outcomes**: Real production data to guide optimization priorities


=== Priority 3: Benchmark Infrastructure Enhancement ðŸ”§

**Goal**: Improve measurement accuracy and coverage

**Tasks**:

1. **Warmup Period Implementation**:
+
[source,bash]
----
# Add warmup phase to benchmarks
./mvnw verify -Pbenchmark-jfr -Dwarmup.duration=60s -Dmeasurement.duration=120s
----

2. **Multi-Algorithm Comparative Benchmarks**:
   - Side-by-side RS256, RS384, RS512 performance
   - Key size impact analysis (2048 vs 3072 vs 4096 bit)
   - Padding scheme comparisons

3. **Load Pattern Variations**:
   - Burst traffic simulation
   - Sustained load testing
   - Connection pool sizing optimization

== Implementation Status

=== Completed Optimizations âœ…

1. **Benchmark Infrastructure**: Maven-based execution with JFR profiling
2. **Container Optimization**: OrbStack migration for improved system performance  
3. **Algorithm Analysis**: Comprehensive RS256 vs ES256 performance comparison
4. **JFR Profiling**: Root cause identification (BigInteger.modPow bottleneck)
5. **ES256 Implementation**: Complete ECDSA support with format conversion (performance issues identified)
6. **Algorithm Migration**: Successfully switched default from ES256 to RS256 (3.1x improvement)
7. **Research Documentation**: Proven 8x ES256/RS256 gap is algorithmic, not implementation-based
8. **BouncyCastle JCA Provider**: Integrated with 17% performance improvement (29ms reduction)

=== In Progress

==== 1. Profile-Guided Optimization (PGO)
**Status:** âŒ NOT AVAILABLE - Mandrel doesn't support PGO

**Research Finding**: PGO is only available in Oracle GraalVM Enterprise Edition. Since Quarkus uses Mandrel (based on GraalVM Community Edition) by default, PGO cannot be used. Would require switching to Oracle GraalVM Enterprise with associated licensing costs.

**Alternative**: Focus on other optimizations available in Mandrel:
- CPU-specific optimizations (-march=native) âœ… **COMPLETED**
- Memory tuning via quarkus.native.native-image-xmx
- Algorithm and key size optimizations

=== Dismissed Items (Do Not Revisit)

==== 1. ES256 Algorithm Migration
**Status:** âŒ DISMISSED - ES256 performs 3x worse than RS256

**Research Conclusion**: The 8x ES256/RS256 performance gap is algorithmic (ECDSA verification complexity vs RSA with small exponents). Java ECDSA implementations are additionally 3x slower than native. Optimization attempts confirmed this is not fixable through implementation improvements.

==== 2. Jipher JCE Provider
**Status:** âŒ DISMISSED - Requires commercial licensing

**Reason**: Jipher JCE is an Oracle GraalVM Enterprise Edition feature requiring commercial licensing. See xref:cui-jwt-quarkus-parent/doc/performance/graalvm-enterprise-optimization-options.adoc[GraalVM Enterprise Optimization Options] for enterprise-specific solutions.

==== 3. Conscrypt JCA Provider  
**Status:** âŒ DISMISSED - Incompatible with Quarkus native

**Research**: Quarkus Issue #4248 documents `ClassNotFoundException: org.conscrypt.BufferAllocator` when using Conscrypt with native images. Requires complex reflection configuration that may not be maintainable.

==== 4. Amazon Corretto Crypto Provider (ACCP)
**Status:** âŒ DISMISSED - Native image compatibility issues

**Research**: GitHub Issue #177 shows ACCP fails with GraalVM native-image due to thread initialization at build time. No official Quarkus native support documented as of 2025.

==== 5. JWT Token Caching Implementation  
**Status:** âŒ DISMISSED - Processing time too high, caching won't solve core issue

==== 6. JWKS Key Retrieval Optimization
**Status:** âŒ DISMISSED - Already optimized and cached

==== 7. TLS/HTTPS Optimization
**Status:** âŒ DISMISSED - No TLS bottleneck identified (3.5ms health check baseline)

==== 8. CPU-Specific Optimization (-march=native)
**Status:** âŒ DISMISSED - Compromises Docker container portability

**Research Finding**: -march=native optimizes for build-time CPU architecture only, not runtime architecture. Since containers may run on different hardware than build environment (ARM64 build vs x86_64 production), this creates deployment compatibility issues. The 1.1% performance gain (1.6ms) doesn't justify the portability risk.

==== 9. Hardware-Specific Acceleration (Intel AES-NI, ARM Crypto Extensions)
**Status:** âŒ DISMISSED - Not suitable for general Docker containers

**Reason**: Hardware-specific optimizations compromise portability. The library must work across different architectures and deployment environments. Always aim for general Docker container compatibility rather than system-specific acceleration.

==== 10. RSA Key Size Optimization
**Status:** âŒ DISMISSED - Not suitable for general library design

**Reason**: The library must support industry-standard key sizes (2048-bit minimum for security). While smaller keys would improve performance (~2x faster with 1024-bit), they are cryptographically insecure. Larger keys (3072-bit) would degrade performance (~2x slower). The library should remain agnostic to key size choices made by token issuers.