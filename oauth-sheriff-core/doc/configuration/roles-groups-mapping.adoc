= Roles and Groups Configuration
:toc: left
:toclevels: 3
:source-highlighter: highlight.js
:toc-title: Table of Contents
:sectnums:


The library provides built-in support for role-based and group-based access control through the "roles" and "groups" claims. These claims are common in many JWT implementations but are not part of the core JWT or OpenID Connect specifications.

== Default Mapping Behavior

By default, both "roles" and "groups" claims use the `JsonCollectionMapper`, which can automatically detect:

* JSON arrays of strings: `"roles": ["admin", "user"]`
* JSON strings (treated as a single value): `"roles": "admin"`

The `JsonCollectionMapper` has the following limitations:

* It only detects JSON arrays and JSON strings
* It does not split space-separated or comma-separated strings
* It treats nested structures as single string values

== Supported JSON Structures

The following JSON structures are automatically detected and properly mapped:

[source,json]
----
// JSON array of strings - each element becomes a separate role/group
{
  "roles": ["admin", "user", "manager"],
  "groups": ["group1", "group2", "group3"]
}

// Single string value - becomes a single-element list
{
  "roles": "admin",
  "groups": "group1"
}

// JSON array with mixed types - non-string values are converted to strings
{
  "roles": ["admin", 123, true],
  "groups": ["group1", {"id": "group2"}]
}
----

== Unsupported JSON Structures

The following JSON structures are NOT automatically split into multiple values by the default `JsonCollectionMapper`:

[source,json]
----
// Space-separated string - treated as a single value "admin user manager"
{
  "roles": "admin user manager"
}

// Comma-separated string - treated as a single value "admin,user,manager"
{
  "roles": "admin,user,manager"
}

// Nested arrays - inner arrays are converted to string representation
{
  "roles": [["admin"], ["user"]]
}

// Custom format - treated as a single value
{
  "roles": "admin:user:manager"
}
----

NOTE: Character-separated strings (like comma or colon-separated) can be handled using the `StringSplitterMapper`. See the <<Using StringSplitterMapper for Delimited Strings>> section for details.

== Using Roles and Groups

The `AccessTokenContent` class provides methods for working with roles and groups:

[source,java]
----
// Get all roles from the token
List<String> roles = accessToken.getRoles();

// Get all groups from the token
List<String> groups = accessToken.getGroups();

// Check if the token has specific roles
boolean hasRoles = accessToken.providesRoles(List.of("admin", "user"));

// Check if the token has specific groups
boolean hasGroups = accessToken.providesGroups(List.of("group1", "group2"));

// Get missing roles
Set<String> missingRoles = accessToken.determineMissingRoles(requiredRoles);

// Get missing groups
Set<String> missingGroups = accessToken.determineMissingGroups(requiredGroups);
----

== Custom Mapping for Roles and Groups

If your identity provider uses a different format for roles or groups, you can configure a custom mapper:

[[Using StringSplitterMapper for Delimited Strings]]
=== Using StringSplitterMapper for Delimited Strings

The library provides a `StringSplitterMapper` that can split string claims by a specified character. This is useful when roles or groups are provided as a single string with values separated by a specific character:

[source,java]
----
// Create a mapper that splits by comma
StringSplitterMapper commaMapper = new StringSplitterMapper(',');

// Create a mapper that splits by colon
StringSplitterMapper colonMapper = new StringSplitterMapper(':');

// Configure the issuer to use the custom mappers
IssuerConfig issuerConfig = IssuerConfig.builder()
        .issuerIdentifier("https://issuer.com")
        .jwksContent(jwksContent) // or other JWKS configuration
        .claimMapper("roles", commaMapper) // For comma-separated roles
        .claimMapper("groups", colonMapper) // For colon-separated groups
        .build();
----

The `StringSplitterMapper` is particularly useful for handling formats that the default `JsonCollectionMapper` doesn't support:

* Comma-separated strings: `"roles": "admin,user,manager"` → `["admin", "user", "manager"]`
* Colon-separated strings: `"roles": "admin:user:manager"` → `["admin", "user", "manager"]`
* Any other character-separated strings

The mapper:

* Only works with string values (not arrays or other types)
* Trims whitespace from each value
* Omits empty values
* Preserves the original string in the claim value

=== Nested Claims Mapping

For complex JWT structures where roles and groups are nested within other claims, configure custom paths:

[source,java]
----
// Configure custom claim paths
RolesGroupsConfig rolesConfig = RolesGroupsConfig.builder()
    .rolesPath("realm_access/roles")  // Nested path for Keycloak
    .groupsPath("resource_access/my-app/roles")  // Deep nesting
    .build();

IssuerConfig issuerConfig = IssuerConfig.builder()
    .issuer("https://example.com")
    .rolesGroupsConfig(rolesConfig)
    .build();
----

=== Custom Claim Mapper Implementation

For complete control over claim mapping, implement the `ClaimMapper` interface:

[source,java]
----
public class CustomRoleMapper implements ClaimMapper {
    @Override
    public List<String> mapClaim(Object claimValue) {
        // Custom logic to extract roles
        if (claimValue instanceof Map) {
            // Handle complex nested structures
        }
        return Collections.emptyList();
    }
}

// Use the custom mapper
IssuerConfig issuerConfig = IssuerConfig.builder()
    .issuerIdentifier("https://issuer.com")
    .claimMapper("roles", new CustomRoleMapper())
    .build();
----